<!DOCTYPE html>
<html lang="en-us">
  
  <head>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline'; object-src 'self'">
    <title>Real-time Local Speech-to-Text with VOX-Style Speaker Detection</title>

    <style>
      body {
        font-family: Arial, sans-serif;
        font-size: 14px;
        margin: 2em;
        padding: 0;
        background-color: #ffffff;
      }
      #output {
        width: 100%;
        height: 100%;
        margin: 0 auto;
        margin-top: 10px;
        border-left: 0px;
        border-right: 0px;
        padding-left: 0px;
        padding-right: 0px;
        display: block;
        background-color: black;
        color: white;
        font-size: 10px;
        font-family: 'Lucida Console', Monaco, monospace;
        outline: none;
        white-space: pre;
        overflow-wrap: normal;
        overflow-x: scroll;
      }
      #speaker-status {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 4px;
        margin-left: 10px;
        font-weight: bold;
        transition: all 0.3s ease;
      }
      .speaking {
        background-color: #4CAF50;
        color: white;
      }
      .silent {
        background-color: #f44336;
        color: white;
      }
      #volume-meter {
        margin-top: 10px;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
      }
      #volume-bar {
        width: 100%;
        height: 20px;
        background-color: #ddd;
        border-radius: 10px;
        overflow: hidden;
      }
      #volume-level {
        width: 0%;
        height: 100%;
        background-color: #2196F3;
        transition: width 0.1s ease;
      }
      #volume-value {
        margin-top: 5px;
        font-family: monospace;
      }
      .speaker-label {
        font-weight: bold;
        padding: 2px 5px;
        border-radius: 3px;
        margin-right: 5px;
      }
      .representative {
        color: #4CAF50;
      }
      .customer {
        color: #2196F3;
      }
      #state-transcribed {
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        white-space: pre-wrap;
        line-height: 1.5;
        max-height: 400px;
        overflow-y: auto;
      }
      .transcription-entry {
        margin-bottom: 8px;
        display: flex;
        align-items: flex-start;
      }
      .speaker-label {
        font-weight: bold;
        padding: 2px 8px;
        border-radius: 3px;
        margin-right: 10px;
        min-width: 100px;
        text-align: right;
      }
      .transcription-text {
        flex: 1;
        padding: 2px 0;
      }
    </style>

  </head>
  <body>
    <div id="main-container">
      <p>
        <b>Real-time Local Speech To Text</b>
        <span id="speaker-status" class="silent">Silent</span>
      </p>

      <div id="volume-meter">
        <div id="volume-bar">
          <div id="volume-level"></div>
        </div>
        <div id="volume-value">Volume: 0</div>
      </div>

      <div id="model-whisper">
       <span id="model-whisper-status"></span>
      
        <span id="fetch-whisper-progress"></span>
      </div>

      <br />

      <div id="input">
        <button id="start" onclick="onStart()" disabled>Start Listening</button>
        <button id="stop" onclick="onStop()" disabled>Stop Listening</button>
      </div>

      <br />

      <div id="state">
        Status: <b><span id="state-status">not started</span></b>
        <div>Current Speaker: <span id="current-speaker-label" class="speaker-label">Customer</span></div>
        <div id="state-transcribed"></div>
      </div>

      <hr />

    <script type="text/javascript" src="./src/helpers.js"></script>
    <script type="text/javascript">
       // web audio context
       var context = null;

// audio data
var audio = null;
var audio0 = null;

// the stream instance
var instance = null;

// model name
var model_whisper = null;

// Global variables for tracking transcription state
var currentTranscriptionSpeaker = 'Customer';
var isTranscribing = false;
var transcriptionStartTime = 0;
var lastTranscriptionText = '';
var currentAudioSegments = [];

function updateTranscription(text) {
  if (!text.trim()) return;  // Skip empty text
  
  const transcribed = document.getElementById('state-transcribed');
  if (!transcribed) return;

  // Create a new entry div
  const entry = document.createElement('div');
  entry.className = 'transcription-entry';
  
  // Add speaker label with timestamp
  const label = document.createElement('span');
  label.className = `speaker-label ${currentTranscriptionSpeaker.toLowerCase()}`;
  const time = new Date().toLocaleTimeString();
  label.textContent = `${currentTranscriptionSpeaker} [${time}]`;
  
  // Add transcription text
  const textSpan = document.createElement('span');
  textSpan.className = 'transcription-text';
  textSpan.textContent = text;
  
  // Assemble and add the entry
  entry.appendChild(label);
  entry.appendChild(textSpan);
  transcribed.appendChild(entry);
  
  // Scroll to bottom
  transcribed.scrollTop = transcribed.scrollHeight;
  
  // Store last text to prevent duplicates
  lastTranscriptionText = text;
}

function setupAudioMonitoring() {
  console.log('Setting up audio monitoring');
  const speakerStatus = document.getElementById('speaker-status');
  const volumeLevel = document.getElementById('volume-level');
  const volumeValue = document.getElementById('volume-value');
  const currentSpeakerLabel = document.getElementById('current-speaker-label');

  let audioUpdateCleanup = window.audioAPI.onAudioUpdate(({ isSpeaking, volume, isFromMic }) => {
    // Update speaker status
    speakerStatus.textContent = isSpeaking ? 'Speaking' : 'Silent';
    speakerStatus.className = isSpeaking ? 'speaking' : 'silent';

    // Update volume display
    const volumePercent = Math.min(100, Math.max(0, volume * 2));
    volumeLevel.style.width = `${volumePercent}%`;
    volumeValue.textContent = `Volume: ${Math.round(volume)}`;

    // Only update speaker label if we're not actively transcribing
    if (!isTranscribing) {
      // Invert the speaker assignment - mic is Representative, desktop is Customer
      currentTranscriptionSpeaker = isFromMic ? 'Representative' : 'Customer';
      
      // Update the visual label
      currentSpeakerLabel.textContent = currentTranscriptionSpeaker;
      currentSpeakerLabel.className = `speaker-label ${currentTranscriptionSpeaker.toLowerCase()}`;
      
      console.log('Speaker updated (not transcribing):', currentTranscriptionSpeaker);
    }
  });

  return audioUpdateCleanup;
}

async function onStart() {
  console.log('Start button clicked');
  transcribedAll = '';
  lastTranscriptionText = '';
  isTranscribing = false;
  
  if (!instance) {
    instance = Module.init('whisper.bin');

    // if (instance) {
    //   printTextarea('js: whisper initialized, instance: ' + instance);
    // }
  }

  if (!instance) {
    printTextarea('js: failed to initialize whisper');
    return;
  }

  try {
    await startRecording();
    console.log('Recording started, setting up audio monitoring');
    audioUpdateCleanup = setupAudioMonitoring();
  } catch (e) {
    console.error('Error starting recording:', e);
  }

  intervalUpdate = setInterval(function () {
    var transcribed = Module.get_transcribed();

    if (transcribed != null && transcribed.length > 1 && transcribed !== lastTranscriptionText) {
      // Mark the start of transcription
      if (!isTranscribing) {
        isTranscribing = true;
        transcriptionStartTime = Date.now();
        console.log('Transcription started, freezing speaker label:', currentTranscriptionSpeaker);
      }
      
      updateTranscription(transcribed);
      
      // Reset transcription state after processing
      isTranscribing = false;
      console.log('Transcription complete, speaker label unfrozen');
    }
  }, 100);
}

function onStop() {
  console.log('Stop button clicked');
  if (audioUpdateCleanup) {
    console.log('Cleaning up audio monitoring');
    audioUpdateCleanup();
    audioUpdateCleanup = null;
  }
  stopRecording();
}

//
// fetch models
//

let dbVersion = 1;
let dbName = 'whisper-voice';
let indexedDB =
  window.indexedDB ||
  window.mozIndexedDB ||
  window.webkitIndexedDB ||
  window.msIndexedDB;

function storeFS(fname, buf) {
  // write to WASM file using FS_createDataFile
  // if the file exists, delete it
  try {
    Module.FS_unlink(fname);
  } catch (e) {
    // ignore
  }

  Module.FS_createDataFile('/', fname, buf, true, true);

  // printTextarea(
  //   'storeFS: stored model: ' + fname + ' size: ' + buf.length
  // );


    document.getElementById('start').disabled = false;
    document.getElementById('stop').disabled = true;
  
}

function loadWhisper(model) {
  let urls = {
    'tiny.en': './static/bin/ggml-model-whisper-tiny.en.bin',
    'tiny-en-q5_1': './src/ggml-model-whisper-tiny.en-q5_1.bin',
    'base-en-q5_1': './static/bin/ggml-model-whisper-base.en-q5_1.bin',
  };

  let sizes = {
    'tiny.en': 75,

    'tiny-en-q5_1': 31,
    'base-en-q5_1': 57,
  };

  let url = urls[model];
  let dst = 'whisper.bin';
  let size_mb = sizes[model];

  model_whisper = model;

  cbProgress = function (p) {
    let el = document.getElementById('fetch-whisper-progress');
    el.innerHTML = Math.round(100 * p) + '%';
  };

  cbCancel = function () {
    var el;
    el = document.getElementById('fetch-whisper-tiny-en');
    if (el) el.style.display = 'inline-block';

    el = document.getElementById('fetch-whisper-tiny-en-q5_1');
    if (el) el.style.display = 'inline-block';
    el = document.getElementById('fetch-whisper-base-en-q5_1');
    if (el) el.style.display = 'inline-block';

    el = document.getElementById('model-whisper-status');
    if (el) el.innerHTML = '';
  };

  loadRemote(
    url,
    dst,
    size_mb,
    cbProgress,
    storeFS,
    cbCancel,
    printTextarea
  );
}

//
// microphone
//

const kSampleRate = 16000;
const kRestartRecording_s = 120;
const kIntervalAudio_ms = 5000; // pass the recorded audio to the C++ instance at this rate

var mediaRecorder = null;
var doRecording = false;
var startTime = 0;

window.AudioContext = window.AudioContext || window.webkitAudioContext;
window.OfflineAudioContext =
  window.OfflineAudioContext || window.webkitOfflineAudioContext;

function stopRecording() {
  Module.set_status('paused');
  doRecording = false;
  audio0 = null;
  audio = null;
  context = null;
}

function startRecording() {
  if (!context) {
    context = new AudioContext({
      sampleRate: kSampleRate,
      channelCount: 1,
      echoCancellation: false,
      autoGainControl: true,
      noiseSuppression: true,
    });
  }

  Module.set_status('');
  isTranscribing = false;
  transcriptionStartTime = 0;

  document.getElementById('start').disabled = true;
  document.getElementById('stop').disabled = false;

  doRecording = true;
  startTime = Date.now();

  var chunks = [];
  var stream = null;

  // Use startAudioCapture directly since we're in the renderer process
  window.startAudioCapture()
    .then(function (mediaStream) {
      stream = mediaStream;
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = function (e) {
        chunks.push(e.data);

        var blob = new Blob(chunks, { type: 'audio/ogg; codecs=opus' });
        var reader = new FileReader();

        reader.onload = function (event) {
          var buf = new Uint8Array(reader.result);

          if (!context) {
            return;
          }
          // Get the current audio source when processing starts
          const micVolume = window.audioAPI.getCurrentVolume();
          const isSpeaking = window.audioAPI.getCurrentSpeaker();
          console.log('Current audio state:', { micVolume, isSpeaking });
          
          // Set speaker based on microphone activity
          currentTranscriptionSpeaker = isSpeaking ? 'Representative' : 'Customer';
          console.log('Setting transcription speaker to:', currentTranscriptionSpeaker);
          
          lastAudioProcessingTime = Date.now();
          
          context.decodeAudioData(
            buf.buffer,
            function (audioBuffer) {
              var offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                audioBuffer.length,
                audioBuffer.sampleRate
              );
              var source = offlineContext.createBufferSource();
              source.buffer = audioBuffer;
              source.connect(offlineContext.destination);
              source.start(0);

              offlineContext
                .startRendering()
                .then(function (renderedBuffer) {
                  audio = renderedBuffer.getChannelData(0);

                  var audioAll = new Float32Array(
                    audio0 == null
                      ? audio.length
                      : audio0.length + audio.length
                  );
                  if (audio0 != null) {
                    audioAll.set(audio0, 0);
                  }
                  audioAll.set(audio, audio0 == null ? 0 : audio0.length);

                  if (instance) {
                    Module.set_audio(instance, audioAll);
                  }
                });
            },
            function (e) {
              audio = null;
            }
          );
        };

        reader.readAsArrayBuffer(blob);
      };

      mediaRecorder.onstop = function (e) {
        if (doRecording) {
          setTimeout(function () {
            startRecording();
          });
        }
      };

      mediaRecorder.start(kIntervalAudio_ms);
    })
    .catch(function (err) {
      printTextarea('js: error getting audio stream: ' + err);
    });

  var interval = setInterval(function () {
    if (!doRecording) {
      clearInterval(interval);
      mediaRecorder.stop();
      stream.getTracks().forEach(function (track) {
        track.stop();
      });

      window.audioAPI.stopCapture();

      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;

      mediaRecorder = null;
    }

    // if audio length is more than kRestartRecording_s seconds, restart recording
    if (
      audio != null &&
      audio.length > kSampleRate * kRestartRecording_s
    ) {
      if (doRecording) {
        clearInterval(interval);
        audio0 = audio;
        audio = null;
        mediaRecorder.stop();
        stream.getTracks().forEach(function (track) {
          track.stop();
        });
      }
    }
  }, 100);
}

//
// main
//

var nLines = 0;
var intervalUpdate = null;
var transcribedAll = '';

let audioUpdateCleanup = null;

function printTextarea(text) {
  if (text.includes('whisper_print_timings:')) {
    return;
  }
  if (text.includes('whisper_model_load: loading')) {
    return;
  }
  if (text.includes('whisper_model_load: n_vocab')) {
    return;
  }
  updateTranscription(text);
}

//Automatically download smallest quantized model
loadWhisper('tiny-en-q5_1')

    </script>
  
    <script type="module" src="./src/renderer.ts"></script>
    <script type="text/javascript" src="./src/stream.js"
  ></script>

  </body>
</html>